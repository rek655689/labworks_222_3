#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <locale.h>

void main1()
{
	setlocale(LC_ALL, "RUS");

	// ЗАДАНИЕ 1. Определите объем памяти, выделяемой под указатель на переменные типа char, int, double
	int* pi = NULL, i = 5;
	float* pf = NULL, f = 2.1f;
	printf("%lu\n", sizeof(pi));  // 8
	printf("%lu\n", sizeof(pf));  // 8
	puts("\n");


	// ЗАДАНИЕ 2. Проанализируйте приведенный ниже код. Объясните результат
	float PI = 3.14159, * p1 = NULL, * p2 = NULL;
	p1 = p2 = &PI;
	printf("По адресу p1=%x хранится *p1=%g\n", p1, *p1);
	printf("По адресу p2=%x хранится *p2=%g\n", p2, *p2);
	// указателям p1 и p2 мы присвоили адрес на одну и ту же переменную, поэтому совпадает как адрес, так и значение, выводимое по этому адресу
	puts("\n");


	// ЗАДАНИЕ 3. Определите, на сколько увеличится значение, на которое указывает ра. Полученные результаты поясните
	int* pa = NULL, x = 5;
	pa = &x;
	printf("По адресу %p хранится *ptr=%d\n", pa, *pa);   // тут должны быть d, а не g;  хранится 5
	pa++;
	printf("По адресу %p хранится *ptr=%d\n", pa, *pa);   // изменился адрес, хранится -858993460
	pa--;
	printf("По адресу %p хранится *ptr=%d\n", pa, *pa);  // адрес прежний, хранится 5
	// инкремент и декремент изменяют адрес, который хранится в указателе, на размер типа указателя (у нас int = 4 байта), т.е. перемещают к другому объекту в памяти
	printf("\n");


	// 3.1. измените тип данных на double
	double* pa_1 = NULL, y = 5;
	pa_1 = &y;
	printf("По адресу %x хранится *ptr=%lg\n", pa_1, *pa_1);   // 5
	pa_1++;
	printf("По адресу %x хранится *ptr=%lg\n", pa_1, *pa_1);   // -9,25596e+61
	pa_1--;
	printf("По адресу %x хранится *ptr=%lg\n", pa_1, *pa_1);  // 5
	// изменение адреса на 8 байт
	printf("\n");


	// 3.2. измените тип данных на char
	char* pa_2 = NULL, c = 'a';
	pa_2 = &c;
	printf("По адресу %x хранится *ptr=%c\n", pa_2, *pa_2);   // a
	pa_2++;
	printf("По адресу %x хранится *ptr=%c\n", pa_2, *pa_2);   // M
	pa_2--;
	printf("По адресу %x хранится *ptr=%c\n", pa_2, *pa_2);  // a
	// изменение адреса на 1 байт
	printf("\n");


	// 3.3. измените тип данных на long double
	long double* pa_3 = NULL, a = 5;
	pa_3 = &a;
	printf("По адресу %x хранится *ptr=%Lg\n", pa_3, *pa_3);   // 5
	pa_3++;
	printf("По адресу %x хранится *ptr=%Lg\n", pa_3, *pa_3);   // -9,25596e+61
	pa_3--;
	printf("По адресу %x хранится *ptr=%Lg\n", pa_3, *pa_3);  // 5
	// изменение адреса на 8 байт
	printf("\n");


	// 3.4. измените тип данных на short unsigned int
	short unsigned int* pa_4 = NULL, b = 5;
	pa_4 = &b;
	printf("По адресу %x хранится *ptr=%hu\n", pa_4, *pa_4);   // 5
	pa_4++;
	printf("По адресу %x хранится *ptr=%hu\n", pa_4, *pa_4);   // 52428
	pa_4--;
	printf("По адресу %x хранится *ptr=%hu\n", pa_4, *pa_4);  // 5
	// изменение адреса на 2 байта
	printf("\n");


	// 3.5. измените тип данных на _Bool
	_Bool* pa_5 = NULL, d = 1;
	pa_5 = &d;
	printf("По адресу %x хранится *ptr=%d\n", pa_5, *pa_5);   // 1
	pa_5++;
	printf("По адресу %x хранится *ptr=%d\n", pa_5, *pa_5);   // 204
	pa_5--;
	printf("По адресу %x хранится *ptr=%d\n", pa_5, *pa_5);  // 1
	// изменение адреса на 1 байт
	puts("\n");


	// ЗАДАНИЕ 4. Исследуйте перемещение по массиву с помощью указателя. Объявите и инициализируйте массив на 10 элементов.
	float array[10] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9, 10.1 };
	float* ptr_a = NULL;
	printf("array = %p, &array[0] = %p, &array = %p\n", array, &array[0], &array);   // всё одинаковое
	ptr_a = &array;
	printf("ptr_a++ = %lg; ptr_a+4 = %lg; ptr_a-2 = %lg\n", *(ptr_a++), *(ptr_a + 4), *(ptr_a - 2));
	// 1.1 так как сначала вывелось значение, а потом сместился указатель
	// и из-за этого потом вывелось 6.6 (стоял на 2.2 и сместился на 4)
	// -1,07374e+08, так как за пределами массива данные другого объекта/мусор

	// цикл прохода по массиву с помощью указателя в прямом порядке с увеличением указателя на 2
	ptr_a = &array;
	for (int i = 0; i < 10; i++)
	{
		printf("a[%d] = %g\n", i + 2, *ptr_a);
		ptr_a += 2;
	}
	printf("\n");

	// проход по массиву в обратном порядке
	ptr_a = &array[9];
	for (int i = 10; i > 0; i--)
	{
		printf("a[%d] = %g\n", i - 1, *ptr_a);
		ptr_a--;
	}
	puts("\n");
}